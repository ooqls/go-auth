// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: resources.query.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const createResource = `-- name: CreateResource :one
INSERT INTO authv1_resources (
  resource_kind,
  resource_group,
  resource_name,
  description,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
) RETURNING resource_group, resource_kind, resource_name, description, created_at, updated_at
`

type CreateResourceParams struct {
	ResourceKind  string
	ResourceGroup string
	ResourceName  string
	Description   sql.NullString
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) CreateResource(ctx context.Context, arg CreateResourceParams) (Authv1Resource, error) {
	row := q.db.QueryRowContext(ctx, createResource,
		arg.ResourceKind,
		arg.ResourceGroup,
		arg.ResourceName,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Authv1Resource
	err := row.Scan(
		&i.ResourceGroup,
		&i.ResourceKind,
		&i.ResourceName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteResource = `-- name: DeleteResource :exec
DELETE FROM authv1_resources WHERE resource_name = $1 AND resource_group = $2 AND resource_kind = $3
`

type DeleteResourceParams struct {
	ResourceName  string
	ResourceGroup string
	ResourceKind  string
}

func (q *Queries) DeleteResource(ctx context.Context, arg DeleteResourceParams) error {
	_, err := q.db.ExecContext(ctx, deleteResource, arg.ResourceName, arg.ResourceGroup, arg.ResourceKind)
	return err
}

const getResourceByID = `-- name: GetResourceByID :one
SELECT resource_group, resource_kind, resource_name, description, created_at, updated_at FROM authv1_resources WHERE resource_name = $1 AND resource_group = $2 AND resource_kind = $3
`

type GetResourceByIDParams struct {
	ResourceName  string
	ResourceGroup string
	ResourceKind  string
}

func (q *Queries) GetResourceByID(ctx context.Context, arg GetResourceByIDParams) (Authv1Resource, error) {
	row := q.db.QueryRowContext(ctx, getResourceByID, arg.ResourceName, arg.ResourceGroup, arg.ResourceKind)
	var i Authv1Resource
	err := row.Scan(
		&i.ResourceGroup,
		&i.ResourceKind,
		&i.ResourceName,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getResources = `-- name: GetResources :many
SELECT resource_group, resource_kind, resource_name, description, created_at, updated_at FROM authv1_resources ORDER BY resource_name LIMIT $1 OFFSET $2
`

type GetResourcesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetResources(ctx context.Context, arg GetResourcesParams) ([]Authv1Resource, error) {
	rows, err := q.db.QueryContext(ctx, getResources, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Authv1Resource
	for rows.Next() {
		var i Authv1Resource
		if err := rows.Scan(
			&i.ResourceGroup,
			&i.ResourceKind,
			&i.ResourceName,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateResource = `-- name: UpdateResource :exec
UPDATE authv1_resources SET
  resource_name = $1,
  description = $2,
  updated_at = now()
WHERE resource_name = $3 AND resource_group = $4 AND resource_kind = $5
`

type UpdateResourceParams struct {
	ResourceName   string
	Description    sql.NullString
	ResourceName_2 string
	ResourceGroup  string
	ResourceKind   string
}

func (q *Queries) UpdateResource(ctx context.Context, arg UpdateResourceParams) error {
	_, err := q.db.ExecContext(ctx, updateResource,
		arg.ResourceName,
		arg.Description,
		arg.ResourceName_2,
		arg.ResourceGroup,
		arg.ResourceKind,
	)
	return err
}
