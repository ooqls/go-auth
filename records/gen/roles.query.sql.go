// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: roles.query.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRole = `-- name: CreateRole :one
INSERT INTO authv1_roles (
  role_name,
  description,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4
) RETURNING id, domain, role_name, role_hierarchy, description, created_at, updated_at
`

type CreateRoleParams struct {
	RoleName    string
	Description string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Authv1Role, error) {
	row := q.db.QueryRowContext(ctx, createRole,
		arg.RoleName,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Authv1Role
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.RoleName,
		&i.RoleHierarchy,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRole = `-- name: DeleteRole :one
DELETE FROM authv1_roles WHERE id = $1 RETURNING id, domain, role_name, role_hierarchy, description, created_at, updated_at
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) (Authv1Role, error) {
	row := q.db.QueryRowContext(ctx, deleteRole, id)
	var i Authv1Role
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.RoleName,
		&i.RoleHierarchy,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT id, domain, role_name, role_hierarchy, description, created_at, updated_at FROM authv1_roles WHERE id = $1
`

func (q *Queries) GetRole(ctx context.Context, id uuid.UUID) (Authv1Role, error) {
	row := q.db.QueryRowContext(ctx, getRole, id)
	var i Authv1Role
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.RoleName,
		&i.RoleHierarchy,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoleAggregate = `-- name: GetRoleAggregate :many
SELECT roles.role_name, roles.role_hierarchy, perm.id, perm.resource_kind, perm.resource_group, perm.resource_name, perm.created_at, perm.updated_at, perm.actions, user_roles.role_id FROM authv1_roles roles
  LEFT JOIN authv1_user_roles user_roles ON roles.id = user_roles.role_id
  LEFT JOIN authv1_role_permissions role_perm ON roles.id = role_perm.role_id
  LEFT JOIN authv1_permissions perm ON role_perm.permission_id = perm.id
WHERE user_roles.user_id = $1
`

type GetRoleAggregateRow struct {
	RoleName      string
	RoleHierarchy int32
	ID            uuid.NullUUID
	ResourceKind  sql.NullString
	ResourceGroup sql.NullString
	ResourceName  sql.NullString
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
	Actions       sql.NullString
	RoleID        uuid.NullUUID
}

func (q *Queries) GetRoleAggregate(ctx context.Context, userID uuid.UUID) ([]GetRoleAggregateRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoleAggregate, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoleAggregateRow
	for rows.Next() {
		var i GetRoleAggregateRow
		if err := rows.Scan(
			&i.RoleName,
			&i.RoleHierarchy,
			&i.ID,
			&i.ResourceKind,
			&i.ResourceGroup,
			&i.ResourceName,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Actions,
			&i.RoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoles = `-- name: GetRoles :many
SELECT id, domain, role_name, role_hierarchy, description, created_at, updated_at FROM authv1_roles WHERE domain = $1 ORDER BY role_name LIMIT $1 OFFSET $2
`

type GetRolesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetRoles(ctx context.Context, arg GetRolesParams) ([]Authv1Role, error) {
	rows, err := q.db.QueryContext(ctx, getRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Authv1Role
	for rows.Next() {
		var i Authv1Role
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.RoleName,
			&i.RoleHierarchy,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesByName = `-- name: GetRolesByName :many
SELECT id, domain, role_name, role_hierarchy, description, created_at, updated_at FROM authv1_roles WHERE role_name = $1
`

func (q *Queries) GetRolesByName(ctx context.Context, roleName string) ([]Authv1Role, error) {
	rows, err := q.db.QueryContext(ctx, getRolesByName, roleName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Authv1Role
	for rows.Next() {
		var i Authv1Role
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.RoleName,
			&i.RoleHierarchy,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRole = `-- name: UpdateRole :one
UPDATE authv1_roles SET
  role_name = $1,
  description = $2,
  updated_at = now()
WHERE id = $3
RETURNING id, domain, role_name, role_hierarchy, description, created_at, updated_at
`

type UpdateRoleParams struct {
	RoleName    string
	Description string
	ID          uuid.UUID
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Authv1Role, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.RoleName, arg.Description, arg.ID)
	var i Authv1Role
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.RoleName,
		&i.RoleHierarchy,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
